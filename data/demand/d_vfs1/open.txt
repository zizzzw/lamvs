COMPAT_SYSCALL_DEFINE2() <COMPAT_SYSCALL_DEFINE2 (ftruncate, unsigned int, fd, compat_ulong_t, length) at open.c:219>:
    do_sys_truncate() <long do_sys_truncate (const char __user *pathname, loff_t length) at open.c:131>:
        lookup_flags
        LOOKUP_FOLLOW
        EINVAL
        retry
        user_path_at()
        AT_FDCWD
        vfs_truncate() <long vfs_truncate (const struct path *path, loff_t length) at open.c:68>:
            error
            S_ISDIR()
            EISDIR
            S_ISREG()
            EINVAL
            mnt_want_write()
            out
            inode_permission()
            MAY_WRITE
            mnt_drop_write_and_out
            EPERM
            IS_APPEND()
            d_real()
            NULL
            O_WRONLY
            PTR_ERR()
            IS_ERR()
            get_write_access()
            break_lease()
            put_write_and_out
            locks_verify_truncate()
            security_path_truncate()
            do_truncate() <int do_truncate (struct dentry *dentry, loff_t length, unsigned int time_attrs, struct file *filp) at open.c:37>:
                EINVAL
                ATTR_SIZE
                ATTR_FILE
                dentry_needs_remove_privs()
                ATTR_FORCE
                inode_lock()
                notify_change()
                NULL
                inode_unlock()
            put_write_access()
            mnt_drop_write()
        path_put()
        retry_estale()
        LOOKUP_REVAL
    do_sys_ftruncate() <long do_sys_ftruncate (unsigned int fd, loff_t length, int small) at open.c:165>:
        EINVAL
        out
        EBADF
        fdget()
        O_LARGEFILE
        S_ISREG()
        FMODE_WRITE
        out_putf
        MAX_NON_LFS
        EPERM
        IS_APPEND()
        file_inode()
        sb_start_write()
        locks_verify_truncate()
        security_path_truncate()
        do_truncate() <int do_truncate (struct dentry *dentry, loff_t length, unsigned int time_attrs, struct file *filp) at open.c:37>:
            EINVAL
            ATTR_SIZE
            ATTR_FILE
            dentry_needs_remove_privs()
            ATTR_FORCE
            inode_lock()
            notify_change()
            NULL
            inode_unlock()
        ATTR_MTIME
        ATTR_CTIME
        sb_end_write()
        fdput()
COMPAT_SYSCALL_DEFINE3() <COMPAT_SYSCALL_DEFINE3 (open, const char __user *, filename, int, flags, umode_t, mode) at open.c:1136>:
    do_sys_open() <long do_sys_open (int dfd, const char __user *filename, int flags, umode_t mode) at open.c:1086>:
        build_open_flags() <inline int build_open_flags (int flags, umode_t mode, struct open_flags *op) at open.c:942>:
            ACC_MODE()
            VALID_OPEN_FLAGS
            O_CREAT
            __O_TMPFILE
            S_IALLUGO
            S_IFREG
            FMODE_NONOTIFY
            O_CLOEXEC
            __O_SYNC
            O_DSYNC
            O_TMPFILE_MASK
            O_TMPFILE
            EINVAL
            MAY_WRITE
            O_PATH
            O_DIRECTORY
            O_NOFOLLOW
            O_TRUNC
            O_APPEND
            MAY_APPEND
            LOOKUP_OPEN
            LOOKUP_CREATE
            O_EXCL
            LOOKUP_EXCL
            LOOKUP_DIRECTORY
            LOOKUP_FOLLOW
        getname()
        IS_ERR()
        PTR_ERR()
        get_unused_fd_flags()
        do_filp_open()
        put_unused_fd()
        fsnotify_open()
        fd_install()
        putname()
    AT_FDCWD
COMPAT_SYSCALL_DEFINE4() <COMPAT_SYSCALL_DEFINE4 (openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode) at open.c:1145>:
    do_sys_open() <long do_sys_open (int dfd, const char __user *filename, int flags, umode_t mode) at open.c:1086>:
        build_open_flags() <inline int build_open_flags (int flags, umode_t mode, struct open_flags *op) at open.c:942>:
            ACC_MODE()
            VALID_OPEN_FLAGS
            O_CREAT
            __O_TMPFILE
            S_IALLUGO
            S_IFREG
            FMODE_NONOTIFY
            O_CLOEXEC
            __O_SYNC
            O_DSYNC
            O_TMPFILE_MASK
            O_TMPFILE
            EINVAL
            MAY_WRITE
            O_PATH
            O_DIRECTORY
            O_NOFOLLOW
            O_TRUNC
            O_APPEND
            MAY_APPEND
            LOOKUP_OPEN
            LOOKUP_CREATE
            O_EXCL
            LOOKUP_EXCL
            LOOKUP_DIRECTORY
            LOOKUP_FOLLOW
        getname()
        IS_ERR()
        PTR_ERR()
        get_unused_fd_flags()
        do_filp_open()
        put_unused_fd()
        fsnotify_open()
        fd_install()
        putname()
SYSCALL_DEFINE0() <SYSCALL_DEFINE0 (vhangup) at open.c:1213>:
    capable()
    CAP_SYS_TTY_CONFIG
    tty_vhangup_self()
    EPERM
SYSCALL_DEFINE1() <SYSCALL_DEFINE1 (close, unsigned int, fd) at open.c:1195>:
    ksys_chdir() <int ksys_chdir (const char __user *filename) at open.c:444>:
        lookup_flags
        LOOKUP_FOLLOW
        LOOKUP_DIRECTORY
        retry
        user_path_at()
        AT_FDCWD
        out
        inode_permission()
        MAY_EXEC
        MAY_CHDIR
        dput_and_out
        set_fs_pwd()
        current
        path_put()
        retry_estale()
        LOOKUP_REVAL
    fdget_raw()
    EBADF
    out
    ENOTDIR
    d_can_lookup()
    out_putf
    inode_permission()
    file_inode()
    MAY_EXEC
    MAY_CHDIR
    set_fs_pwd()
    current
    fdput()
    ksys_chroot() <int ksys_chroot (const char __user *filename) at open.c:497>:
        lookup_flags
        LOOKUP_FOLLOW
        LOOKUP_DIRECTORY
        retry
        user_path_at()
        AT_FDCWD
        out
        inode_permission()
        MAY_EXEC
        MAY_CHDIR
        dput_and_out
        EPERM
        ns_capable()
        current_user_ns()
        CAP_SYS_CHROOT
        security_path_chroot()
        set_fs_root()
        current
        path_put()
        retry_estale()
        LOOKUP_REVAL
    __close_fd()
    unlikely()
    ERESTARTSYS
    ERESTARTNOINTR
    ERESTARTNOHAND
    ERESTART_RESTARTBLOCK
    EINTR
SYSCALL_DEFINE2() <SYSCALL_DEFINE2 (creat, const char __user *, pathname, umode_t, mode) at open.c:1157>:
    do_sys_truncate() <long do_sys_truncate (const char __user *pathname, loff_t length) at open.c:131>:
        lookup_flags
        LOOKUP_FOLLOW
        EINVAL
        retry
        user_path_at()
        AT_FDCWD
        vfs_truncate() <long vfs_truncate (const struct path *path, loff_t length) at open.c:68>:
            error
            S_ISDIR()
            EISDIR
            S_ISREG()
            EINVAL
            mnt_want_write()
            out
            inode_permission()
            MAY_WRITE
            mnt_drop_write_and_out
            EPERM
            IS_APPEND()
            d_real()
            NULL
            O_WRONLY
            PTR_ERR()
            IS_ERR()
            get_write_access()
            break_lease()
            put_write_and_out
            locks_verify_truncate()
            security_path_truncate()
            do_truncate() <int do_truncate (struct dentry *dentry, loff_t length, unsigned int time_attrs, struct file *filp) at open.c:37>:
                EINVAL
                ATTR_SIZE
                ATTR_FILE
                dentry_needs_remove_privs()
                ATTR_FORCE
                inode_lock()
                notify_change()
                NULL
                inode_unlock()
            put_write_access()
            mnt_drop_write()
        path_put()
        retry_estale()
        LOOKUP_REVAL
    do_sys_ftruncate() <long do_sys_ftruncate (unsigned int fd, loff_t length, int small) at open.c:165>:
        EINVAL
        out
        EBADF
        fdget()
        O_LARGEFILE
        S_ISREG()
        FMODE_WRITE
        out_putf
        MAX_NON_LFS
        EPERM
        IS_APPEND()
        file_inode()
        sb_start_write()
        locks_verify_truncate()
        security_path_truncate()
        do_truncate() <int do_truncate (struct dentry *dentry, loff_t length, unsigned int time_attrs, struct file *filp) at open.c:37>:
            EINVAL
            ATTR_SIZE
            ATTR_FILE
            dentry_needs_remove_privs()
            ATTR_FORCE
            inode_lock()
            notify_change()
            NULL
            inode_unlock()
        ATTR_MTIME
        ATTR_CTIME
        sb_end_write()
        fdput()
    do_faccessat() <long do_faccessat (int dfd, const char __user *filename, int mode) at open.c:358>:
        cred
        old_cred
        lookup_flags
        LOOKUP_FOLLOW
        S_IRWXO
        EINVAL
        prepare_creds()
        ENOMEM
        issecure()
        SECURE_NO_SETUID_FIXUP
        kuid_t
        root_uid
        make_kuid()
        uid_eq()
        cap_clear()
        override_creds()
        retry
        user_path_at()
        out
        d_backing_inode()
        MAY_EXEC
        S_ISREG()
        EACCES
        path_noexec()
        out_path_release
        inode_permission()
        MAY_ACCESS
        S_IWOTH
        special_file()
        __mnt_is_readonly()
        EROFS
        path_put()
        retry_estale()
        LOOKUP_REVAL
        revert_creds()
        put_cred()
    AT_FDCWD
    ksys_fchmod() <int ksys_fchmod (unsigned int fd, umode_t mode) at open.c:564>:
        fdget()
        EBADF
        audit_file()
        chmod_common() <int chmod_common (const struct path *path, umode_t mode) at open.c:535>:
            NULL
            mnt_want_write()
            retry_deleg
            inode_lock()
            security_path_chmod()
            out_unlock
            S_IALLUGO
            ATTR_MODE
            ATTR_CTIME
            notify_change()
            inode_unlock()
            break_deleg_wait()
            mnt_drop_write()
        fdput()
    do_fchmodat() <int do_fchmodat (int dfd, const char __user *filename, umode_t mode) at open.c:582>:
        lookup_flags
        LOOKUP_FOLLOW
        retry
        user_path_at()
        chmod_common() <int chmod_common (const struct path *path, umode_t mode) at open.c:535>:
            NULL
            mnt_want_write()
            retry_deleg
            inode_lock()
            security_path_chmod()
            out_unlock
            S_IALLUGO
            ATTR_MODE
            ATTR_CTIME
            notify_change()
            inode_unlock()
            break_deleg_wait()
            mnt_drop_write()
        path_put()
        retry_estale()
        LOOKUP_REVAL
    ksys_open()
    O_CREAT
    O_WRONLY
    O_TRUNC
SYSCALL_DEFINE3() <SYSCALL_DEFINE3 (open, const char __user *, filename, int, flags, umode_t, mode) at open.c:1114>:
    do_faccessat() <long do_faccessat (int dfd, const char __user *filename, int mode) at open.c:358>:
        cred
        old_cred
        lookup_flags
        LOOKUP_FOLLOW
        S_IRWXO
        EINVAL
        prepare_creds()
        ENOMEM
        issecure()
        SECURE_NO_SETUID_FIXUP
        kuid_t
        root_uid
        make_kuid()
        uid_eq()
        cap_clear()
        override_creds()
        retry
        user_path_at()
        out
        d_backing_inode()
        MAY_EXEC
        S_ISREG()
        EACCES
        path_noexec()
        out_path_release
        inode_permission()
        MAY_ACCESS
        S_IWOTH
        special_file()
        __mnt_is_readonly()
        EROFS
        path_put()
        retry_estale()
        LOOKUP_REVAL
        revert_creds()
        put_cred()
    do_fchmodat() <int do_fchmodat (int dfd, const char __user *filename, umode_t mode) at open.c:582>:
        lookup_flags
        LOOKUP_FOLLOW
        retry
        user_path_at()
        chmod_common() <int chmod_common (const struct path *path, umode_t mode) at open.c:535>:
            NULL
            mnt_want_write()
            retry_deleg
            inode_lock()
            security_path_chmod()
            out_unlock
            S_IALLUGO
            ATTR_MODE
            ATTR_CTIME
            notify_change()
            inode_unlock()
            break_deleg_wait()
            mnt_drop_write()
        path_put()
        retry_estale()
        LOOKUP_REVAL
    do_fchownat() <int do_fchownat (int dfd, const char __user *filename, uid_t user, gid_t group, int flag) at open.c:653>:
        EINVAL
        AT_SYMLINK_NOFOLLOW
        AT_EMPTY_PATH
        out
        LOOKUP_FOLLOW
        LOOKUP_EMPTY
        retry
        user_path_at()
        mnt_want_write()
        out_release
        chown_common() <int chown_common (const struct path *path, uid_t user, gid_t group) at open.c:611>:
            NULL
            kuid_t
            uid
            kgid_t
            gid
            make_kuid()
            current_user_ns()
            make_kgid()
            retry_deleg
            ATTR_CTIME
            uid_t
            uid_valid()
            EINVAL
            ATTR_UID
            gid_t
            gid_valid()
            ATTR_GID
            S_ISDIR()
            ATTR_KILL_SUID
            ATTR_KILL_SGID
            ATTR_KILL_PRIV
            inode_lock()
            security_path_chown()
            notify_change()
            inode_unlock()
            break_deleg_wait()
        mnt_drop_write()
        path_put()
        retry_estale()
        LOOKUP_REVAL
    AT_FDCWD
    AT_SYMLINK_NOFOLLOW
    ksys_fchown() <int ksys_fchown (unsigned int fd, uid_t user, gid_t group) at open.c:702>:
        fdget()
        EBADF
        out
        mnt_want_write_file_path()
        out_fput
        audit_file()
        chown_common() <int chown_common (const struct path *path, uid_t user, gid_t group) at open.c:611>:
            NULL
            kuid_t
            uid
            kgid_t
            gid
            make_kuid()
            current_user_ns()
            make_kgid()
            retry_deleg
            ATTR_CTIME
            uid_t
            uid_valid()
            EINVAL
            ATTR_UID
            gid_t
            gid_valid()
            ATTR_GID
            S_ISDIR()
            ATTR_KILL_SUID
            ATTR_KILL_SGID
            ATTR_KILL_PRIV
            inode_lock()
            security_path_chown()
            notify_change()
            inode_unlock()
            break_deleg_wait()
        mnt_drop_write_file_path()
        fdput()
    force_o_largefile()
    O_LARGEFILE
    do_sys_open() <long do_sys_open (int dfd, const char __user *filename, int flags, umode_t mode) at open.c:1086>:
        build_open_flags() <inline int build_open_flags (int flags, umode_t mode, struct open_flags *op) at open.c:942>:
            ACC_MODE()
            VALID_OPEN_FLAGS
            O_CREAT
            __O_TMPFILE
            S_IALLUGO
            S_IFREG
            FMODE_NONOTIFY
            O_CLOEXEC
            __O_SYNC
            O_DSYNC
            O_TMPFILE_MASK
            O_TMPFILE
            EINVAL
            MAY_WRITE
            O_PATH
            O_DIRECTORY
            O_NOFOLLOW
            O_TRUNC
            O_APPEND
            MAY_APPEND
            LOOKUP_OPEN
            LOOKUP_CREATE
            O_EXCL
            LOOKUP_EXCL
            LOOKUP_DIRECTORY
            LOOKUP_FOLLOW
        getname()
        IS_ERR()
        PTR_ERR()
        get_unused_fd_flags()
        do_filp_open()
        put_unused_fd()
        fsnotify_open()
        fd_install()
        putname()
SYSCALL_DEFINE4() <SYSCALL_DEFINE4 (openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode) at open.c:1122>:
    ksys_fallocate() <int ksys_fallocate (int fd, int mode, loff_t offset, loff_t len) at open.c:336>:
        fdget()
        EBADF
        vfs_fallocate() <int vfs_fallocate (struct file *file, int mode, loff_t offset, loff_t len) at open.c:239>:
            file_inode()
            ret
            EINVAL
            FALLOC_FL_SUPPORTED_MASK
            EOPNOTSUPP
            FALLOC_FL_PUNCH_HOLE
            FALLOC_FL_ZERO_RANGE
            FALLOC_FL_KEEP_SIZE
            FALLOC_FL_COLLAPSE_RANGE
            FALLOC_FL_INSERT_RANGE
            FALLOC_FL_UNSHARE_RANGE
            FMODE_WRITE
            EBADF
            IS_APPEND()
            EPERM
            IS_IMMUTABLE()
            IS_SWAPFILE()
            ETXTBSY
            security_file_permission()
            MAY_WRITE
            S_ISFIFO()
            ESPIPE
            S_ISDIR()
            EISDIR
            S_ISREG()
            S_ISBLK()
            ENODEV
            EFBIG
            file_start_write()
            fsnotify_modify()
            file_end_write()
        fdput()
    force_o_largefile()
    O_LARGEFILE
    do_sys_open() <long do_sys_open (int dfd, const char __user *filename, int flags, umode_t mode) at open.c:1086>:
        build_open_flags() <inline int build_open_flags (int flags, umode_t mode, struct open_flags *op) at open.c:942>:
            ACC_MODE()
            VALID_OPEN_FLAGS
            O_CREAT
            __O_TMPFILE
            S_IALLUGO
            S_IFREG
            FMODE_NONOTIFY
            O_CLOEXEC
            __O_SYNC
            O_DSYNC
            O_TMPFILE_MASK
            O_TMPFILE
            EINVAL
            MAY_WRITE
            O_PATH
            O_DIRECTORY
            O_NOFOLLOW
            O_TRUNC
            O_APPEND
            MAY_APPEND
            LOOKUP_OPEN
            LOOKUP_CREATE
            O_EXCL
            LOOKUP_EXCL
            LOOKUP_DIRECTORY
            LOOKUP_FOLLOW
        getname()
        IS_ERR()
        PTR_ERR()
        get_unused_fd_flags()
        do_filp_open()
        put_unused_fd()
        fsnotify_open()
        fd_install()
        putname()
SYSCALL_DEFINE5() <SYSCALL_DEFINE5 (fchownat, int, dfd, const char __user *, filename, uid_t, user, gid_t, group, int, flag) at open.c:685>:
    do_fchownat() <int do_fchownat (int dfd, const char __user *filename, uid_t user, gid_t group, int flag) at open.c:653>:
        EINVAL
        AT_SYMLINK_NOFOLLOW
        AT_EMPTY_PATH
        out
        LOOKUP_FOLLOW
        LOOKUP_EMPTY
        retry
        user_path_at()
        mnt_want_write()
        out_release
        chown_common() <int chown_common (const struct path *path, uid_t user, gid_t group) at open.c:611>:
            NULL
            kuid_t
            uid
            kgid_t
            gid
            make_kuid()
            current_user_ns()
            make_kgid()
            retry_deleg
            ATTR_CTIME
            uid_t
            uid_valid()
            EINVAL
            ATTR_UID
            gid_t
            gid_valid()
            ATTR_GID
            S_ISDIR()
            ATTR_KILL_SUID
            ATTR_KILL_SGID
            ATTR_KILL_PRIV
            inode_lock()
            security_path_chown()
            notify_change()
            inode_unlock()
            break_deleg_wait()
        mnt_drop_write()
        path_put()
        retry_estale()
        LOOKUP_REVAL
dentry_open() <struct file *dentry_open (const struct path *path, int flags, const struct cred *cred) at open.c:911>:
    validate_creds()
    BUG_ON()
    get_empty_filp()
    IS_ERR()
    vfs_open() <int vfs_open (const struct path *path, struct file *file, const struct cred *cred) at open.c:899>:
        d_real()
        NULL
        IS_ERR()
        PTR_ERR()
        do_dentry_open() <int do_dentry_open (struct file *f, struct inode *inode, int (*open) (struct inode *, struct file *), const struct cred *cred) at open.c:737>:
            OPEN_FMODE()
            FMODE_LSEEK
            FMODE_PREAD
            FMODE_PWRITE
            path_get()
            filemap_sample_wb_err()
            unlikely()
            O_PATH
            FMODE_PATH
            empty_fops <const struct file_operations empty_fops at open.c:742>
            FMODE_WRITE
            special_file()
            get_write_access()
            cleanup_file
            __mnt_want_write()
            put_write_access()
            FMODE_WRITER
            S_ISREG()
            S_ISDIR()
            FMODE_ATOMIC_POS
            fops_get()
            WARN_ON()
            ENODEV
            cleanup_all
            security_file_open()
            break_lease()
            locks_inode()
            FMODE_READ
            i_readcount_inc()
            likely()
            FMODE_CAN_READ
            FMODE_CAN_WRITE
            WRITE_LIFE_NOT_SET
            O_CREAT
            O_EXCL
            O_NOCTTY
            O_TRUNC
            file_ra_state_init()
            fops_put()
            __mnt_drop_write()
            path_put()
            NULL
        d_backing_inode()
    open_check_o_direct() <int open_check_o_direct (struct file *f) at open.c:727>:
        O_DIRECT
        EINVAL
    fput()
    ERR_PTR()
    put_filp()
file_open_root() <struct file *file_open_root (struct dentry *dentry, struct vfsmount *mnt, const char *filename, int flags, umode_t mode) at open.c:1055>:
    build_open_flags() <inline int build_open_flags (int flags, umode_t mode, struct open_flags *op) at open.c:942>:
        ACC_MODE()
        VALID_OPEN_FLAGS
        O_CREAT
        __O_TMPFILE
        S_IALLUGO
        S_IFREG
        FMODE_NONOTIFY
        O_CLOEXEC
        __O_SYNC
        O_DSYNC
        O_TMPFILE_MASK
        O_TMPFILE
        EINVAL
        MAY_WRITE
        O_PATH
        O_DIRECTORY
        O_NOFOLLOW
        O_TRUNC
        O_APPEND
        MAY_APPEND
        LOOKUP_OPEN
        LOOKUP_CREATE
        O_EXCL
        LOOKUP_EXCL
        LOOKUP_DIRECTORY
        LOOKUP_FOLLOW
    ERR_PTR()
    do_file_open_root()
file_path() <char *file_path (struct file *filp, char *buf, int buflen) at open.c:887>:
    d_path()
filp_clone_open() <struct file *filp_clone_open (struct file *oldfile) at open.c:1066>:
    get_empty_filp()
    IS_ERR()
    vfs_open() <int vfs_open (const struct path *path, struct file *file, const struct cred *cred) at open.c:899>:
        d_real()
        NULL
        IS_ERR()
        PTR_ERR()
        do_dentry_open() <int do_dentry_open (struct file *f, struct inode *inode, int (*open) (struct inode *, struct file *), const struct cred *cred) at open.c:737>:
            OPEN_FMODE()
            FMODE_LSEEK
            FMODE_PREAD
            FMODE_PWRITE
            path_get()
            filemap_sample_wb_err()
            unlikely()
            O_PATH
            FMODE_PATH
            empty_fops <const struct file_operations empty_fops at open.c:742>
            FMODE_WRITE
            special_file()
            get_write_access()
            cleanup_file
            __mnt_want_write()
            put_write_access()
            FMODE_WRITER
            S_ISREG()
            S_ISDIR()
            FMODE_ATOMIC_POS
            fops_get()
            WARN_ON()
            ENODEV
            cleanup_all
            security_file_open()
            break_lease()
            locks_inode()
            FMODE_READ
            i_readcount_inc()
            likely()
            FMODE_CAN_READ
            FMODE_CAN_WRITE
            WRITE_LIFE_NOT_SET
            O_CREAT
            O_EXCL
            O_NOCTTY
            O_TRUNC
            file_ra_state_init()
            fops_put()
            __mnt_drop_write()
            path_put()
            NULL
        d_backing_inode()
    put_filp()
    ERR_PTR()
filp_close() <int filp_close (struct file *filp, fl_owner_t id) at open.c:1168>:
    file_count()
    printk()
    KERN_ERR
    likely()
    FMODE_PATH
    dnotify_flush()
    locks_remove_posix()
    fput()
filp_open() <struct file *filp_open (const char *filename, int flags, umode_t mode) at open.c:1042>:
    getname_kernel()
    ERR_CAST()
    IS_ERR()
    file_open_name() <struct file *file_open_name (struct filename *name, int flags, umode_t mode) at open.c:1024>:
        build_open_flags() <inline int build_open_flags (int flags, umode_t mode, struct open_flags *op) at open.c:942>:
            ACC_MODE()
            VALID_OPEN_FLAGS
            O_CREAT
            __O_TMPFILE
            S_IALLUGO
            S_IFREG
            FMODE_NONOTIFY
            O_CLOEXEC
            __O_SYNC
            O_DSYNC
            O_TMPFILE_MASK
            O_TMPFILE
            EINVAL
            MAY_WRITE
            O_PATH
            O_DIRECTORY
            O_NOFOLLOW
            O_TRUNC
            O_APPEND
            MAY_APPEND
            LOOKUP_OPEN
            LOOKUP_CREATE
            O_EXCL
            LOOKUP_EXCL
            LOOKUP_DIRECTORY
            LOOKUP_FOLLOW
        ERR_PTR()
        do_filp_open()
        AT_FDCWD
    putname()
finish_no_open() <int finish_no_open (struct file *file, struct dentry *dentry) at open.c:880>
finish_open() <int finish_open (struct file *file, struct dentry *dentry, int (*open) (struct inode *, struct file *), int *opened) at open.c:849>:
    BUG_ON()
    FILE_OPENED
    do_dentry_open() <int do_dentry_open (struct file *f, struct inode *inode, int (*open) (struct inode *, struct file *), const struct cred *cred) at open.c:737>:
        OPEN_FMODE()
        FMODE_LSEEK
        FMODE_PREAD
        FMODE_PWRITE
        path_get()
        filemap_sample_wb_err()
        unlikely()
        O_PATH
        FMODE_PATH
        empty_fops <const struct file_operations empty_fops at open.c:742>
        FMODE_WRITE
        special_file()
        get_write_access()
        cleanup_file
        __mnt_want_write()
        put_write_access()
        FMODE_WRITER
        S_ISREG()
        S_ISDIR()
        FMODE_ATOMIC_POS
        fops_get()
        WARN_ON()
        ENODEV
        cleanup_all
        security_file_open()
        break_lease()
        locks_inode()
        FMODE_READ
        i_readcount_inc()
        likely()
        FMODE_CAN_READ
        FMODE_CAN_WRITE
        WRITE_LIFE_NOT_SET
        O_CREAT
        O_EXCL
        O_NOCTTY
        O_TRUNC
        file_ra_state_init()
        fops_put()
        __mnt_drop_write()
        path_put()
        NULL
    d_backing_inode()
    current_cred()
generic_file_open() <int generic_file_open (struct inode *inode, struct file *filp) at open.c:1228>:
    O_LARGEFILE
    i_size_read()
    MAX_NON_LFS
    EOVERFLOW
nonseekable_open() <int nonseekable_open (struct inode *inode, struct file *filp) at open.c:1243>:
    FMODE_LSEEK
    FMODE_PREAD
    FMODE_PWRITE
